<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Syntax Parser</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="social-links top-left">
        <a href="https://github.com/Dreamlord4k" target="_blank" rel="noopener noreferrer">
            <img src="assets/icons/github.png" alt="GitHub" class="icon">
        </a>
        <a href="https://t.me/MrCrstl" target="_blank" rel="noopener noreferrer">
            <img src="assets/icons/telegram.png" alt="Telegram" class="icon">
        </a>
    </div>
    <header>
        <h1 id="typing-effect">Syntax Parser</h1>
    </header>
    <main>
        <p id="typing-effect-paragraph">Этот проект позволяет парсить оценки и пропуски из электронного дневника dnevnik.egov66.ru</p>
        <p id="typing-effect-paragraph-2">С помощью этого проекта вы сможете легко отслеживать свои оценки, а также получать уведомления о любых изменениях.</p>
        <div class="image-container">
            <div class="left-text" id="left-text-container">
                <p>Что мы предлагаем?</p>
                <p>1. Удобный формат просмотра оценок</p>
                <p>2. Отсутствие необходимости постоянно логиниться на сайт электронного дневника</p>
                <p>3. Уведомления о новых оценках и пропусках</p>
                <p>4. Полностью открытый исходный код программы.</p>
                <p>5. Теоретически рабочую программу</p>
            </div>
            <img src="assets/galaxy.jpg" alt="Galaxy Background" class="background-image">
            <div class="right-text" id="right-text-container">
                <h3>Как это работает?</h3>
                <ul>
                    <li>- Есть сервер, где находится база данных и телеграмм бот</li>
                    <li>- Со стороны пользователя нужно лишь проследовать инструкцям на github и держать открытой консоль</li>
                    <li>- Программа будет парсить оценки каждые 30 секунд</li>
                    <li>- При любом добавлении оценки вам придет уведомление.</li>
                </ul>
            </div>
        </div>
        </div>
        <div class="additional-info">
             <p>Это один из самых масштабных проектов <b>лицея 12</b> (разумеется после тапалки)</p>
             <p>И все это реализовано без какого-либо API для разработчиков</p>
             <p><b>Скачать можно на github, там же все инструкции и исходный код</b></p>
             <a href="https://github.com/Dreamlord4k/dnevnik.egov66.ru-parser" target="_blank" rel="noopener noreferrer" class="download-button">скачать</a>
             <p>В случае каких-либо вопросов пишите мне в телеграмм</p>
        </div>
    </main>
    <footer>
        <p>© 2025 Syntax Parser. Все права защищены.(я лично защитил)</p>
    </footer>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const headerText = "Syntax Parser";
        const paragraphText1 = "Этот проект позволяет парсить оценки и пропуски из электронного дневника dnevnik.egov66.ru";
        const paragraphText2 = "С помощью этого проекта вы сможете легко отслеживать свои оценки, а также получать уведомления о любых изменениях.";
        const headerElement = document.getElementById("typing-effect");
        const paragraphElement1 = document.getElementById("typing-effect-paragraph");
        const paragraphElement2 = document.getElementById("typing-effect-paragraph-2");
        const leftTextContainer = document.getElementById("left-text-container");
        const leftTextLines = leftTextContainer.querySelectorAll("p"); // Get all <p> elements in left container
        const rightTextContainer = document.getElementById("right-text-container");
        const rightTextElements = rightTextContainer.querySelectorAll("h3, li"); // Get heading and list items in right container

        let headerIndex = 0;
        let paragraphIndex1 = 0;
        let paragraphIndex2 = 0;
        let leftTextIndex = 0; // Index for left text lines animation
        let rightTextIndex = 0; // Index for right text elements animation
        // Очистить текст перед началом анимации
        headerElement.textContent = "";
        paragraphElement1.textContent = "";
        paragraphElement2.textContent = "";
        leftTextLines.forEach(line => line.style.opacity = "0"); // Hide left text lines initially
        rightTextElements.forEach(el => el.style.opacity = "0"); // Hide right text elements initially

        function typeHeader() {
            if (headerIndex < headerText.length) {
                headerElement.textContent += headerText[headerIndex];
                headerIndex++;
                setTimeout(typeHeader, 100); // Скорость печати заголовка
            } else {
                // После завершения анимации заголовка, начать анимацию первого параграфа
                setTimeout(typeParagraph1, 500); // Задержка перед началом анимации первого параграфа
            }
        }

        function typeParagraph1() {
            if (paragraphIndex1 < paragraphText1.length) {
                paragraphElement1.textContent += paragraphText1[paragraphIndex1];
                paragraphIndex1++;
                setTimeout(typeParagraph1, 60); // Скорость печати первого параграфа
            } else {
                // После завершения анимации первого параграфа, начать анимацию второго параграфа
                setTimeout(typeParagraph2, 500); // Задержка перед началом анимации второго параграфа
            }
        }

        function typeParagraph2() {
            if (paragraphIndex2 < paragraphText2.length) {
                paragraphElement2.textContent += paragraphText2[paragraphIndex2];
                paragraphIndex2++;
                setTimeout(typeParagraph2, 45); // Скорость печати второго параграфа
            } else {
                // После завершения анимации второго параграфа, начать анимацию строк слева
                setTimeout(showLeftTextLines, 500); // Задержка перед началом анимации строк слева
            }
        }

        function showLeftTextLines() {
            if (leftTextIndex < leftTextLines.length) {
                leftTextLines[leftTextIndex].style.opacity = "1"; // Плавное появление строки
                leftTextLines[leftTextIndex].style.transition = "opacity 1s ease"; // Анимация появления
                leftTextIndex++;
                setTimeout(showLeftTextLines, 1300); // Delay before showing the next left line
            } else {
                // After showing all left lines, start showing right text elements
                setTimeout(showRightTextElements, 500); // Delay before starting right text animation
            }
        }

        function showRightTextElements() {
            if (rightTextIndex < rightTextElements.length) {
                rightTextElements[rightTextIndex].style.opacity = "1"; // Fade in the element
                rightTextElements[rightTextIndex].style.transition = "opacity 1s ease"; // Animation effect
                rightTextIndex++;
                setTimeout(showRightTextElements, 1000); // Delay before showing the next right element
            }
        }

        // Start the header typing animation
        typeHeader();
    });
    </script>
</body>
</html>